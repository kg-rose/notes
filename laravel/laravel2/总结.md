# 各种扩展的使用
1. mews/captcha => 验证码
    * 安装命令 `composer require "mews/captcha:~2.0"`
    * 发布扩展资源 `php artisan vendor:publish --provider='Mews\Captcha\CaptchaServiceProvider'` => 这里我之前有个误区，以为就是把默认配置复制一份到 config/ 目录下，其实不仅只有配置文件，还有其他的比如前端资源等等。
    * 使用方法：
        * 视图层上直接用 `<img src="{{ captcha_src('样式') }}">` 调出验证码图片
        ```
        <img src="{{ captcha_src('flat') }}" onclick="this.src='/captcha/flat?'+Math.random()" title="点击图片重新获取验证码">
        ```
        > 这里的 `onclick="this.src='/captcha/flat?'+Math.random()"` 是为了实现点击刷新
        * 验证
        ```
        // rules
            'captcha' => 'required|captcha',

        // messages
            'captcha.required' => '验证码不能为空',
            'captcha.captcha' => '请输入正确的验证码',
        ```
2. overtrue/laravel-lang => 汉化包（数据验证时错误提示变成中文）
    * 安装命令 `composer require "overtrue/laravel-lang:~3.0"`
    * 需要配置 config/app.php `'locale' => 'zh-CN',`
    * 额外说一下开发环境下 laravel 框架装好后应该配置的那些东西：
        1. 配置主机的 hosts ：命令 `notepad C:/Windows/System32/Drivers/etc/hosts` => 打开hosts文件，添加 `192.168.10.10 项目网站`
        2. 打开 Homestead.yaml `code ~/Homestead/Homestead.yaml` 编辑 
        ```
        # 站点配置
        sites:
            - map: 项目网站
            to: /home/vagrant/Code/项目目录/public

        # 数据库
        databases:
            - 数据库名，建议和项目目录是一样的
        ```
        3. 依次执行下面两条命令：
        ```
        vagrant provision       <= 让 Homestead.yaml 配置生效
        vagrant reload          <= 重启 homestead （重启虚拟机）
        ```
        4. 配置 .env 文件
        ```
        APP_NAME= #项目名称
        APP_URL= #项目网站
        DB_DATABASE= #数据库名
        ```
        5. 配置 config/app.php
        ```
        'name' => env('APP_NAME', 'laraBBS'),           //项目名称
        'url' => env('APP_URL', 'http://larabbs.test'), //项目网址
        'timezone' => 'Asia/Shanghai',                  //时区
        'locale' => 'zh-CN',                            //语言
        ```
        6. 配置 Carbon 的语言为中文（Carbon 是一个laravel自带的时间相关扩展）
        ```
        # app/Providers/AppServiceProvider.php
        use Carbon\Carbon; //引用 Carbon 类

        ...

            public function boot()
            {
                Carbon::setLocale('zh'); // <= 设置为中文
            }
        ```
        > `env('.env文件的配置项名称', '默认值')` => 这是读取 .env 文件中的某个配置，如果没有值就用第二参数默认值。
        > 此时访问 “项目网站” 那个网址就可以看到部署好的 laravel 项目。
3. intervention/image => 图片裁剪
    * 安装扩展 `composer require intervention/image`
    * 发布扩展资源 `php artisan vendor:publish --provider="Intervention\Image\ImageServiceProviderLaravel5"` => 生成配置文件 config/image.php。
4. summerblue/generator => 生成代码骨架
    * 安装命令 `composer require "summerblue/generator:~0.5" --dev`
    * 使用方法：执行命令 `php artisan make:scaffold Test --schema="字段:类型:约束:默认值:索引,字段:类型必填,..."`
    > 关键字 `make:scaffold` 创建骨架
    > 关键字 `Test` 是模型名称，之后会根据这个关键字，创建一些文件，有些需要复数形式命名的文件会自动变复数。
    > 关键字 `--schema="..."` 这是在配置数据表字段。
    * 上面的命令做了这些事
        * 根据 --schema 的配置，创建迁移文件 Migration，模型工厂 Factory，和数据填充 Seede，并执行迁移。
        * 创建模型 Test ,控制器 TestController ,以及三张视图（位于 resources/views/tests/ :create_and_edit, index, show ）。
        * 在 routes/web.php 中定制 tests 的资源路由
        * 创建请求验证类 TestRequest
        * 创建授权策略类 TestPolicy ， 并在 AuthServiceProvider 中注册
        * 创建话题模型事件监控器 TestObserver 并在 AppServiceProvider 中注册
        * 自动执行一次 `composer dump-autoload` 以更新 classmap
5. barryvdh/laravel-debugbar => laravel 专用的 debug 工具栏
    * 安装命令 `composer require "barryvdh/laravel-debugbar:~3.1" --dev`
    * 发布资源 `php artisan vendor:publish --provider="Barryvdh\Debugbar\ServiceProvider"` => 生成 config/debugbar.php
    * 需要配置一下是否开启，建议编辑 config/debugbar.php ，写成这样 `'enabled' => env('APP_DEBUG', false),` => 读 .env 的 APP_DEBUG 配置项，默认不开启。（如果 .env 配置开启，则开启）
6. hieu-le/active => 判断路由，给页面元素（导航按钮）添加样式
    * 安装命令 `composer require "hieu-le/active:~3.5"`
    * 这个扩展包提供一下全局函数
    ```
    active_class(BOOLEAN, 样式名1='默认active', 样式名2='默认为空字符串');
    // 最常用：判断第一个参数，第一个参数为真，用样式1，否则，用样式2。
    // 这个方法位于 vendor/hieu-le/active/src/Facades/helpers.php 中
    // 因为默认为 'active' 所以如果用 bootstrap337 作为前端 ui 框架，那么就不用给这个函数后面的参数了。

    /* 一下这些方法常常作为上面函数的第一参数，返回值都是布尔 */
        if_route('路由名称')                // 判断当前路由的路由名称
        if_route_param('参数名', 值)        // 判断当前路由的隐性参数是否等于给的值
        if_query('参数名', 值)              // 判断当前路由的参数(这里的参数是说：网站?参数名=值，就是判断问号后面的那个)

    ```
7. guzzlehttp/guzzle => http 请求发送，常用于请求接口
    * 安装命令 `composer require "guzzlehttp/guzzle:~6.3"`
    * 具体用法：
        ```
        // 首先你需要配置好你要请求的接口
        $url = 'xxx.com?'; //这里的 ? 用于后面拼接 url 参数

        // 然后这个接口如果需要什么参数可以这样生成 url 参数
        $query = http_build_query(给个键值对数组) // 将这个数组转成 "键=值&键=值" 这样的格式，多用于请求接口时配置参数
        
        // 然后实例化 GuzzleHttp\Client 类
        $http = new GuzzleHttp\Client;

        // 然后请求接口
        $response = $http->get($url . $query);

        // 你可以这样获得响应体
        $response->getBody();
        ```
8. overtrue/pinyin => 国内大神写的汉字转拼音
    * 安装命令 `composer require "overtrue/pinyin:~3.0"`
    * 使用方法很简单，这里主要顺带记录一下 `str_slug` 这个 laravel 框架提供的生成 slug 的方法:
    ```
    return str_slug(app(Pinyin::class)->permalink(要翻译的文字));
    ```
    > 这里 `app(PinYin::class)->permalink('汉字')` 返回的结果是 “han zi”
    > 而 `str_slug('han zi')` 返回的结果就是 “han-zi” 了。
9. 队列任务相关扩展（predis 和 horizon ，写在队列任务部分了）
10. 权限管理相关扩展（laravel-permission 和 laravel_administrator ，单独写在权限管理部分）
11. sudosu => 自由切换用户，方便测试权限管理
    * 安装命令 `composer require "viacreative/sudo-su:~1.1"`
    * 安装完成后需要
    ```
    # 注册 app/Providers/AppserviceProvider.php@register
        public function register()
        {
            // 添加下面的代码
            if (app()->isLocal()) { //当是本地项目时，注册下面这个服务
                $this->app->register(\VIACreative\SudoSu\ServiceProvider::class);
            }
        }

    # 执行命令发布资源 
        php artisan vendor:publish --provider="VIACreative\SudoSu\ServiceProvider"
            => 生成一个 样式文件 public/sudo-su/ 和 配置文件 config/sudosu.php
    
    # 编辑配置文件 config/sudosu.php
        <?php

        return [

            // 允许使用的顶级域名
            'allowed_tlds' => ['dev', 'local', 'test'], // 这个配置项大白话说就是我们配置的虚拟域名如果后面是 www.xxx.【dev】 或者 www.xxx.【local】 或者 www.xxx.【test】 才可以使用。

            // 用户模型
            'user_model' => App\Models\User::class

        ];

    # 在布局模板上引用
        @if (app()->isLocal())
            @include('sudosu::user-selector')
        @endif
    ```
    > `app()->isLocal()` => 读的就是 .env 中的 APP_ENV=local 的值，当是 local 的时候，就说明项目跑在本地开发环境。这个函数就是说：当项目处于本地开发环境下的时候，注册 sudosu 插件提供的服务。
    
    > 此时就可以看得到那个可以随意切换用户的小图标。

    > 一定要先注册插件，再发布资源
    
# 模型
1. 修改默认模型存放文件夹（建议）
    > 默认模型文件是直接放 app/ 目录下的，我发现很多开发者喜欢把模型还是放在 app/Models/ 目录下，那么少数服从多数，我们也这么做。（项目一旦部署完成之后就应该进行，因为一开始只有一个 User 模型，后面模型多了非常麻烦）
    * 将 app/User.php 剪切到 app/Models/User.php，并编辑：命名空间改成 `namespace App\Models;`
    * 【ctrl】+【shift】+【f】 全局查找替换 `use App\User` => `use App\Models\User;`
2. 模型观察器的定义、注册
    * 模型观察器建议都放在 app/Observers/ 目录下，命名格式为 ModelObserver.php 
    * 一个基本的模型观察器是这样的
    ```
    <?php

    namespace App\Observers;

    use App\Models\Reply; //引用模型

    class ReplyObserver
    {
        public function craeting(Reply $reply)
        {
            // 这个方法就是说当 $reply 在入库前需要做那些操作
        }

        /*
            除了 creating 还有以下这些方法
            creating, created, updating, updated, saving,
            saved,  deleting, deleted, restoring, restored
        */
    }
    ```
    * 模型观察器需要在 AppServiceProvider.php 中注册
    ```
    \App\Models\Link::observe(\App\Observers\LinkObserver::class);
    ```
    > 模型::observe(模型观察器类);
3. set{字段}Attribute 和 get{字段}Attribute 的使用
    > 其实这个东西和模型观察器的逻辑很像：它就是说在“设置某个字段、或者读取某个字段的值的时候，作一些其他的处理”
    * 举例
    ```
    # User@setPasswordAttribute => 在给 密码 字段赋值时，作下面的操作
    public function setPasswordAttribute($value)
    {
        // 如果值的长度等于 60，即认为是已经做过加密的情况
        if (strlen($value) != 60) {

            // 不等于 60，做密码加密处理
            $value = bcrypt($value);
        }

        $this->attributes['password'] = $value;
    }
    ```
4. scope方法
    * 定义 scope 方法
    ```
    public function scopeExample($query, 参数2)
    {
        return $query->where()
            ->with()
            ->orderBy()
            ->...
    }
    ```
    > 上面定义的方法方法名叫 `scopeExample` ,但调用它的时候应该写为 `example()` （不要 scope 且首字母小写）
    * **scope 方法的特性**
        * **总是返回查询构造器**
        * **参数中的 $query 指调用这个方法之前的查询构造器**
        * **scope方法最后需要把新的 $query 返回回去**
        * 听起来很抽象，解释起来也很麻烦，不如这样理解：这些方法就是为了满足某些共同的查询条件而定义出来的，比如无论帖子或者回复的列表页，都需要“根据id倒序排序”的查询结果，那么我们可以创建一个 app/Models/Model.php 作为 Model 范类，并定义这样一个方法
        ```
        <?php

        namespace App\Models;

        use Illuminate\Database\Eloquent\Model as EloquentModel;

        class Model extends EloquentModel
        {
            public function scopeRecent($query)
            {
                return $query->orderBy('id', 'desc');
            }
        }
        ```
        > 这里需要先继承 `Illuminate\Database\Eloquent\Model` 这个类
        > 然后此时就可以定义一个其他子类可以继承的方法 `scopeRecent`，当其他子类的实例在查询过程中调用 `..->recent()` 方法时，就相当于添加了查询条件 “根据id倒序排序”
5. 使用 Trait 为模型瘦身 => 可以把 trait 理解为方法集合
    * 建议都放在 app/Models/Traits/ 目录下
    * 只需要注意这不是在定义类，所以定义 trait 时应该 `trait trait名 { //...trait 内容 }`
    * 在模型中引用 trait 的方法就是 `class 模型名 ... { use 你要用的trait; }`

# Request 请求类
1. 创建 `php artisan make:request XxxRequest` => 创建一个请求类，位于 app/Http/Requests/ 目录下
2. 所有请求类都继承同目录下的 Request.php，且它只有一个方法 `authorize()` => 权限认证
```
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class Request extends FormRequest
{
    public function authorize()
    {
    	// Using policy for Authorization
        return true;
    }
}
```
> 但其实我们不常用这种方法写权限认证，而是用 Policy（参考教程一的总结）。所以所有 `Request@authorize` 都直接 `return true`
* 一个常见的请求类应该是这样的
```
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Auth;

class UserRequest extends FormRequest
{
    /**
     * 权限认证,直接返回 true
     */
    public function authorize()
    {
        return true;
    }

    /**
     * 请求发送过来的数据验证
     */
    public function rules()
    {
        return [
           '要验证的字段' => '规则1|规则2|...',
           ...
        ];
    }

    /**
     * 验证不通过后的错误提示信息
     */
    public function messages()
    {
        return [
            '字段.规则' => '错误提示信息',
            ...
        ];
    }
}
```
* 要将验证投入使用只需要在参数列表中，实例化 `$request` 时，使用指定的验证类作为注入容器即可：`public function xxx(XxxRequest $request)`

# 视图
1. 视图上的那些判断方法
    * `@guest` => 判断浏览者是不是游客身份
    ```
    @guest
        <!-- 如果是游客显示这一部分内容 -->
    @else
        <!-- 如果登陆了显示这一部分内容 -->
    @endguest
    ```
2. 数据校验出错给输入框加红框
    > 依赖 bootstrap 提供的 has-error 样式（其他的前端 ui 框架可能也有，只需要改成响应的类名就行了）
    * `<div class="form-group{{ $errors->has('password') ? ' has-error' : '' }}">` => 通过三元运算判断 `$errors->has('字段')` 给这个 div 加 `has-error` 样式或者空 `''` 样式即可。
    * 额外说一下输入两次密码验证的方法：
    ```
    1.  视图上的密码输入框
    <input id="password" type="password" class="form-control" name="password" required>
    <input id="password-confirm" type="password" class="form-control" name="password_confirmation" required>
    {{-- 这里重复密码的那个字段需要叫 password_confirmation --}}

    1. 验证的 rules 则可以
    'password' => 'required|confirmed', // <= confirmed 校验
    ```

# Handlers
> 这其实是一种思想：相当于自己建一个工具类封装某些操作的方法，然后其他需要用到这些方法的类引用这个类，并且在参数列表中实例化该类即可。
> 我们把 Handler 这些类都放在 app/Handlers/ 目录下，写法就是普通类的写法，命名空间写成 `namespace App\Handlers;` 即可。

# 图片上传
1. [我自己的写法](https://github.com/prohorry-me/laravel_image_uploader_demo)
2. 教程中的写法：看不到效果，但是编辑器要用
    * 视图
    ```
    {{-- 首先无论哪种写法，表单必须加上 --}}
    <form ... enctype="multipart/form-data">
        
        {{-- 这是头像的 --}}
        <div class="form-group">
            <label for="" class="avatar-label">用户头像</label>
            <input type="file" name="avatar">

            @if($user->avatar)
                <br>
                <img class="thumbnail img-responsive" src="{{ $user->avatar }}" width="200" />
            @endif
        </div>
    ```
    * app/Handlers/ImageUploadHandler.php
    ```
    <?php

    namespace App\Handlers;
    use Image;

    class ImageUploadHandler
    {
        // 合法文件后缀
        protected $allowed_ext = ["png", "jpg", "gif", 'jpeg'];

        /**
        * 图片上传
        */
        public function save($file, $folder, $file_prefix, $max_width = false) //参数 (文件对象, 文件夹名称, 文件前缀名用上传图片的用户的id, 图片最大宽度，如果传参就将进行裁剪)
        {
            // 文件夹切割能让查找效率更高： ../uploads/images/文件夹名称/年月/日/
            $folder_name = "uploads/images/$folder/" . date("Ym/d", time());

            // 文件具体存储的物理路径： public_path() = 框架根/public
            $upload_path = public_path() . '/' . $folder_name;

            // 获取文件后缀名： $file->getClientOriginalExtension() 获取文件的后缀名，如果没有默认为 png
            $extension = strtolower($file->getClientOriginalExtension()) ?: 'png';

            // 拼出文件名 用户id_当前时间戳_随机10个字符.后缀名
            $filename = $file_prefix . '_' . time() . '_' . str_random(10) . '.' . $extension;

            // in_array(变量, 数组)： 看变量是否存在于数组中，即判断后缀名是否合法
            if (!in_array($extension, $this->allowed_ext)) {
                return false; //不合法就直接返回 false 
            }

            // 将图片移动到我们的目标存储路径中 move(移动到的目录, 新的文件名)
            $file->move($upload_path, $filename);

            // 如果限制了图片宽度，就进行裁剪
            if ($max_width && $extension != 'gif') {

                // 此类中封装的函数，用于裁剪图片
                $this->reduceSize($upload_path . '/' . $filename, $max_width);
            }

            // 将图片地址最终返回 config('app.url') 即我们在 .env 里面配置的 APP_URL，这里因为 public/ 是入口文件所在地址，所以需要省略 public/ 
            return [
                'path' => config('app.url') . "/$folder_name/$filename",
            ];
        }

        /**
        * 图片裁剪
        */
        public function reduceSize($file_path, $max_width)
        {
            // 先实例化，传参是文件的磁盘物理路径
            $image = Image::make($file_path);

            // 进行大小调整的操作
            $image->resize($max_width, null, function ($constraint) {

                // 设定宽度是 $max_width，高度等比例双方缩放
                $constraint->aspectRatio();

                // 防止裁图时图片尺寸变大
                $constraint->upsize();
            });

            // 对图片修改后进行保存
            $image->save();
        }
    }
    ```
    > 依赖图片裁剪扩展 intervention/image。
    * 控制器层的逻辑需要增加
    ```
    // 外面引用 ImageUploadHandler
    use App\Handlers\ImageUploadHandler;

    ...

        // 参数列表中实例化 ImageUploadHandler 为 $uploader
        public function update(UserRequest $request, ImageUploadHandler $uploader, User $user)
        {   
            // 获取表单数据
            $data = $request()->all();

            // 上传头像
            if($request->avatar) {
                $res = $uploader->save($request->avatar, 'avatars', $user->id);
                if($res) {
                    $data['avatar'] = $res['path'];
                }
            }

            // 更新数据
            $user->update($data);

            // 发送提示消息
            session()->flash('success', '编辑个人资料成功');

            // 重定向到个人信息页
            return redirect()->route('users.show', $user);
        }
    ```
    > 这是来自用户编辑个人资料的方法： UsersController@update ：当有头像的时候就调用 Handler 的 save 方法裁剪图片并且存好，返回一个图片地址。
    * 关于图片验证
    ```
    // rules()
    'avatar' => 'mimes:jpeg,bmp,png,gif|dimensions:min_width=200,min_height=200',

    ...

    // messages()
        'avatar.mimes' =>'头像必须是 jpeg, bmp, png, gif 格式的图片',
        'avatar.dimensions' => '图片的清晰度不够，宽和高需要 200px 以上',
    ```
    > `mimes:格式` => 验证后缀名
    > `dimensions:最大小宽度单位px,用逗号指定多个` => 验证图片宽高

# simiditor 编辑器
1. [下载地址](https://github.com/mycolorway/simditor/releases)
2. 集成方法（其他插件集成也可以参考）
    * 把文件放在 resources/assets/插件名/css 和 resources/assets/插件名/js/ 目录下
    * 编辑 webpack.mix.js，之后编译 `npm run dev`
    ```
    mix.js('resources/assets/js/app.js', 'public/js')
    .sass('resources/assets/sass/app.scss', 'public/css')
    
    // 用 copyDirectory() 声明等下要复制这些文件
    .copyDirectory('resources/assets/simditor/js', 'public/js')
    .copyDirectory('resources/assets/simditor/css', 'public/css')
    ;
    ```
    * 在布局模板上声明两个占位符
    ```
    <!-- Styles -->
        <link href="{{ asset('css/app.css') }}" rel="stylesheet">
        @yield('styles')

    <!-- Scripts -->
        <script src="{{ asset('js/app.js') }}"></script>
        @yield('scripts')
    ```
    * 需要调用的页面，比如在 created_and_edit.blade.php 中调用 simditor
    ```
    @section('styles')
        <link rel="stylesheet" type="text/css" href="{{ asset('css/simditor.css') }}">
    @stop

    @section('scripts')
        <script type="text/javascript"  src="{{ asset('js/module.js') }}"></script>
        <script type="text/javascript"  src="{{ asset('js/hotkeys.js') }}"></script>
        <script type="text/javascript"  src="{{ asset('js/uploader.js') }}"></script>
        <script type="text/javascript"  src="{{ asset('js/simditor.js') }}"></script>

        <script>
        $(document).ready(function(){
            var editor = new Simditor({
                textarea: $('#editor'),
            });
        });
        </script>

    @stop
    ```
3. 完成它的图片上传功能
    * 配置路由 `Route::post('upload_image', 'TopicsController@uploadImage')->name('topics.upload_image');`
    * 编辑 TopicsController@uploadImage
    ```
    use App\Handlers\ImageUploadHandler; //引用之前写的 Handler

    ...

        public function uploadImage(Request $request, ImageUploadHandler $uploader)
        {
            // 初始化返回数据，默认是失败的
            $data = [
                'success'   => false,
                'msg'       => '上传失败!',
                'file_path' => ''
            ];
            // 判断是否有上传文件，并赋值给 $file
            if ($file = $request->upload_file) {
                // 保存图片到本地并裁剪
                $result = $uploader->save($request->upload_file, 'topics', \Auth::id(), 120);
                // 图片保存成功的话
                if ($result) {
                    $data['file_path'] = $result['path'];
                    $data['msg']       = "上传成功!";
                    $data['success']   = true;
                }
            }
            return $data;
        }
    ```
    * 编辑前台
    ```
    @section('scripts')

        ...
        
        <script>
            $(document).ready(function(){
                var editor = new Simditor({
                    textarea: $('#editor'), //配置输入域 id
                    upload: { //文件上传配置
                        url: '{{ route('topics.upload_image') }}', //上传图片请求的路由
                        params: { _token: '{{ csrf_token() }}' }, //csrf
                        fileKey: 'upload_file', //文件名
                        connectionCount: 3, //最多上传3张图片
                        leaveConfirm: '文件上传中，关闭此页面将取消上传。' //上传过程中，用户关闭页面时的提醒。
                    },
                    pasteImage: true, //设定是否支持图片黏贴上传，这里我们使用 true 进行开启
                });
            });
        </script>

    @stop
    ```

# 消息通知类
1. 数据库通知准备工作
    * 使用数据库通知需要先弄一个通知表 `php artisan notifications:table` => 数据通知频道会在一张数据表里存储所有通知信息。包含了比如通知类型、JSON 格式数据等描述通知的信息。我们后面会通过查询这张表的内容在应用界面上展示通知。
    * 如果有需要（比如本项目通过 users 表增加字段：notification_count，当有新的回复时发送通知给数据库，并给 notification_count 字段自增以提示用户有新回复），可以给其他数据表增加一个用于提示有新通知的字段，略。
    > 记得执行迁移 `php artisan migrate`
2. 邮件通知准备工作
    > 记得配置 .env 邮件相关，建议 smtp。
3. 通知类的写法
    * 创建 `php artisan make:notification Xxx` => 创建的通知类位于 app/Notifications/ 目录下
    * 通知类的常见写法：
    ```
    <?php

    namespace App\Notifications;

    use Illuminate\Bus\Queueable;
    use Illuminate\Notifications\Notification;
    use Illuminate\Contracts\Queue\ShouldQueue;
    use Illuminate\Notifications\Messages\MailMessage;
    use App\Models\Reply;

    class TopicReplied extends Notification implements ShouldQueue
    {
        use Queueable;

        public $reply;

        public function __construct(Reply $reply)
        {
            // 注入回复实体，方便 toDatabase 方法中的使用
            $this->reply = $reply;
        }

        public function via($notifiable)
        {
            // 开启通知的频道
            return ['database', 'mail'];
        }

        /**
        * 数据库通知
        */
        public function toDatabase($notifiable)
        {
            $topic = $this->reply->topic;
            $link =  $topic->link(['#reply' . $this->reply->id]);

            // 存入数据库里的数据
            return [
                'reply_id' => $this->reply->id,
                'reply_content' => $this->reply->content,
                'user_id' => $this->reply->user->id,
                'user_name' => $this->reply->user->name,
                'user_avatar' => $this->reply->user->avatar,
                'topic_link' => $link,
                'topic_id' => $topic->id,
                'topic_title' => $topic->title,
            ];
        }

        /**
        * 邮件通知
        */
        public function toMail()
        {   
            $topic = $this->reply->topic;

            $link =  $topic->link(['#reply' . $this->reply->id]);
            
            return (new MailMessage)
                ->subject('有新回复')
                ->line('你发布的话题《' . $topic->title . '》有新回复')
                ->action('点击查看', $link);
        }
    }
    ```
    >  `__constrct()` 主要是为了接收等会要用的参数
    >  `via()` 是在配置通知的频道，如果你配置了 `['database', 'mail']` 就是说要用数据库和邮件频道，那么你就必须写 `toDatabase()` 和 `toMail()` 两个方法
    > `toDatabase()`的写法就是 return 回去一个数组，内容为要写进数据表的数据
    > `toMail` 的写法就是 return 然后用 `(new MailMessage)` 来填充通知邮件的内容，调用会自动发送邮件。
4. 通知类的调用方法
    > 通知类的调用方法通常写在 User 模型中，因为 User 模型引用了 trait `use Notifiable;` 而通知相关的都写在这里面。
    * 以 User 模型为例
    ```
    use Illuminate\Notifications\Notifiable;
    use App\Notifications\ResetPasswordNotification;

    ...

        public function sendPasswordResetNotification($token)
        {
            $this->notify(new ResetPasswordNotification($token));
        }
    ```
    > 直接用 `$this->notify(new 通知类)` 调用 Notifiable@notify 方法发送密码重置邮件。
    * trait 方法改名：保留这个方法，然后改写 notify 方法。
    ```
    use Notifiable {
        notify as protected laravelNotify; //将 notify 方法改名为 laravelNotify
    }

    public function notify($instance)
    {
        $this->increment('notification_count');
        $this->laravelNotify($instance);
    }
    ```
    > 这里这么做是为了依然保留 Notifiable@notify （只不过方法改名为 LaravelNotify 了）然后我们自己写个 notify 方法就不会覆盖 Notifiable@notify ，然后我们在里面添加一个逻辑：自增之前添加的 notification_count 字段。
    > 同时这样一来我们就可以通过 `$user->notify()` 来发送通知了。
5. 清空通知 `$this->unreadNotifications->markAsRead();` => User 模型中调用。

# 队列任务
> 这里是用 redis 作队列任务
1. 需要的扩展：
    * predis/predis => 让 php 支持 redis 缓存
        * 安装命令 `composer require "predis/predis:~1.0"`
        * 需要配置 .env `QUEUE_DRIVER=redis`
        * 需要生成并执行迁移文件，以创建failed_jobs 表，用于记录失败的队列任务
        ```
        php artisan queue:failed-table
        php artisan migrate
        ```
    * horizon （虽然可选但是强烈推荐，一个 laravel 官方的队列任务监控面板）
        * 安装命令 `composer require "laravel/horizon:~1.0"`
        * 发布资源（必须） `php artisan vendor:publish --provider="Laravel\Horizon\HorizonServiceProvider"` => 生成配置文件和视图模板
        * 开启监控使用命令 `php artisan horizon`，访问面板是 `项目网站/horizon`
        * 在项目正式上线时，可以考虑权限控制，设置只有站长或者高级管理员才能访问 horizon 面板，这一部分在权限管理那里说。
2. 创建、编辑和使用队列任务
    * 创建命令 `php artisan make:job 任务名首字母大写驼峰命名法`
    * 编辑通常就是写 app/Jobs/队列任务@handle() 方法，比如本项目为了完成 slug 我们写了个队列任务 TranslateSlug 它的 handle() 方法是这样的
    ```
    public function handle()
    {
        $slug = app(SlugTranslateHandler::class)->translate($this->topic->title); //调用 Handler 请求接口翻译 title

        // 这里必须用 \DB::table() 来读取表数据然后修改，而不能实例化模型
        \DB::table('topics')->where('id', $this->topic->id)->update(['slug' => $slug]);
    }
    ```
    > 以后队列任务更新数据库就都要用 `DB::table('表名')` 来直接获取数据表的实例。
    * 使用队列任务，即调用队列任务。
    ```
    use App\Jobs\TranslateSlug; // 这里是引用 TranslateSlug 这个类

    ...

        public function saved(Topic $topic)
        {
            // 如 slug 字段无内容，即使用翻译器对 title 进行翻译
            if ( ! $topic->slug) {

                // 推送任务到队列
                dispatch(new TranslateSlug($topic));
            }
        }
    ```
    > `dispatch(new 队列任务(参数))` => 推送到队列任务（记录下来，异步执行）

# 权限管理
1. laravel 自带的权限管理
    * 系统自带的中间件：
    ```
    // 举例，在禁止游客访问的控制器中：
    public function __construct()
    {
        $this->middleware('auth');
    }
    ```
    > 当然还有 `guest` 中间件等（用于登陆注册控制器中）
    * 授权策略：Policy
    ```
    # TopicPolicy@destroy => 进行判断：当前用户是否是发帖的人（普通用户只能删自己发的帖子）
    public function destroy(User $user, Topic $topic)
    {
        return $user->isAuthorOf($topic);
    }

    # 然后在控制层，用下面的代码进行授权
    $this->authorize('destroy', $topic);

    # 或者在视图层，用下面的代码对删除按钮进行显示和隐藏（判断渲染与否）
    @can('destroy', $topic)
    @endcan
    ```
2. 多角色权限管理
    * 确定角色：确定我们开发的应用中有哪些角色，比如这次的论坛项目有角色：游客，普通用户，管理员，站长。
    * 通过 laravel 自带的权限管理工具（中间件和 Policy ）已经完成了 游客 | 普通用户，以及 普通用户用户之间（用户只能删自己的帖、用户只能删自己的回复啊等等）的权限管理。
    * 接下来就需要做管理员和站长的权限了
        * 装扩展 laravel_permission => 用于权限管理 `composer require "spatie/laravel-permission:~2.7"`
        * 发布资源-迁移文件 `php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider" --tag="migrations"` => 生成迁移文件，记得执行迁移（创建5张数据表：权限表，角色表，权限角色关系表，角色用户关系表，权限用户关系表）、
        ```
        权限表 -> 配置权限名称，比如 manage_contents (管理内容)
        角色表 -> 配置角色名称，比如 Founder (站长)
        权限角色关系表 -> 这张表存储角色和权限的关系，一个角色有多个关系，比如 Founder 站长有所有权限。
        角色用户关系表 -> 这张表存储用户和角色的关系，一个用户有多个角色，比如1号用户可以扮演 Founder。
        权限用户关系表 -> 这张表存储权限和用户的关系，即跳过上一张表，直接给用户权限而不是给用户角色。
        ```
        * 发布资源-配置文件 `php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider" --tag="config"` => 生成 config/permisson.php（目前不用管他）
        * 项目开发过程中，为了开发方便，做了这些事：
            1. User 模型中引用权限管理相关的 trait
            ```
            use Spatie\Permission\Traits\HasRoles;

            ...

                use HasRoles;
            ```
            2. 溜了一个迁移文件用于配置默认的站长和管理员 `php artisan make:migration seed_roles_and_permissions_data`
            ```
            // 这里是 laravel_permission 扩展提供的两个模型文件
            use Spatie\Permission\Models\Role;
            use Spatie\Permission\Models\Permission;

                // up()
                    // 清除缓存
                    app()['cache']->forget('spatie.permission.cache');

                    // 创建权限 Persisson::create(['name' => '权限名'])
                    Permission::create(['name' => 'manage_contents']);
                    Permission::create(['name' => 'manage_users']);
                    Permission::create(['name' => 'edit_settings']);

                    // 创建角色 Role::create(['name' => '角色名'])
                    $founder = Role::create(['name' => 'Founder']); //站长
                    // 赋予权限 $角色->givePermessionTo('权限名')
                    $founder->givePermissionTo('manage_contents');
                    $founder->givePermissionTo('manage_users');
                    $founder->givePermissionTo('edit_settings');

                    // 创建管理员角色
                    $maintainer = Role::create(['name' => 'Maintainer']);
                    $maintainer->givePermissionTo('manage_contents');

                // down()
                    // 清除缓存
                    app()['cache']->forget('spatie.permission.cache');

                    // 清空所有数据表数据
                    $tableNames = config('permission.table_names'); //这一步应该是读取数据表名前缀配置项
                    Model::unguard(); //记得解除模型保护
                    DB::table($tableNames['role_has_permissions'])->delete(); // 扩展包的数据表名都叫做 $前缀['数据表名']
                    DB::table($tableNames['model_has_roles'])->delete();
                    DB::table($tableNames['model_has_permissions'])->delete();
                    DB::table($tableNames['roles'])->delete();
                    DB::table($tableNames['permissions'])->delete();
                    Model::reguard(); //最后重新开启模型保护
            ```
            3. 给1号用户（我们开发中一直以来的假定的管理员）Founder 角色，给2号用户（方便我们等下测试）管理员角色。在 UsersTableSeeder 中实现
            ```
            // 配置用户
            $user = User::find(1);

            //... 这一部分是我们设置用户的用户名、密码等。

            // 配置权限  $user->assignRole('角色')
            $user->assignRole('Founder');

            $user = User::find(2); //重新找2号用户存当前 user
            $user->assignRole('Maintainer'); //给普通管理员角色
            ```
            4. 装了一个 sudosu 的扩展，详情参考第一部分 “各种扩展使用”
        * 此时其实就已经完成了权限管理，在开发到这里时，我们已经写了两个授权策略文件(TopicPolicy 和 ReplyPolicy)，这两个文件都是用于：判断当前用户是不是帖子或者回复的作者，只有是帖子或者回复的作者时，才可以删帖、编辑帖、删除回复。接下来，我们想让拥有权限 `manage_contents` 的用户，有删除、编辑其他用户的帖子，以及删除其他人的回复的功能。
        > 这里就用了一个小技巧：直接写 Policy@before 方法：Policy 类作为其他（除了 UserPolicy 外） Policy 的基类（被继承），它提供一个 bofore 方法，当这个方法返回真的时候，直接就授权了，当返回假的时候，才去调用指定的授权认证。
        ```
        public function before($user, $ability)
        {
            if ($user->can('manage_contents')) {
                return true;
            }
        }
        ```
        * horizon 面板的访问权限配置
        ```
        # app/Provider/AuthServiceProvider@boot 
        public function boot()
        {
            $this->registerPolicies();

            \Horizon::auth(function ($request) {
                // 是否是站长
                return \Auth::user()->hasRole('Founder');
            });
        }
        ```
    * laravel_permission 常用方法
        * 创建权限
        ```
        use Spatie\Permission\Models\Permission; //确保引用 Permission 模型

        ...

            Permission::craete(['name' => '权限名']); //只用给 name 赋值
        ```
        * 创建角色并授予权限
        ```
        use Spatie\Permission\Models\Role; //确保引用 Role 模型

        ...

            $role = Role::create(['name' => '角色名']); //同样只用给 name 赋值，返回的就是当前创建的角色
            $role->givePermissionTo('权限名'); //给角色赋予指定权限
        ```
        > 下面的代码需要确保 User 模型中有 `HasRoles` 这个 trait
        * 给用户授予角色
        ```
        # 确保 User 模型引用 trait HasRoles 。
        use Spatie\Permission\Traits\HasRoles;

        class User extends Authenticatable
        {
            use HasRoles;
        }

        # 在需要的地方
        $user->assignRole('角色名');   
        ```
        * 判断用户是否有某权限
        ```
        $user->can('权限名');
        ```
        * 判断用户是否有某角色
        ```
        $user->hasRole('角色名');
        ```
3. laravel_administrator 后台管理面板
    > 这是国内大神写的扩展：只需要简单的几个配置文件，就可以自动部署一个后台（不用管视图部分）
    * 安装命令 `composer require "summerblue/administrator:~1.1"`
    * 安装完成后需要做
    ```
    # 发布资源 
    php artisan vendor:publish --provider="Frozennode\Administrator\AdministratorServiceProvider"

    # 创建文件夹 
    mkdir config/administrator config/administrator/settings

    # 视图提供的图片上传按钮过大，需要添加样式 overflow:hidden 来避免按钮覆盖其他的表单项(在 public/packages/js/plupload/js/plupload.full.js 中找 “999px” 附近)。

    # 其他比如用户管理中，以管理员身份修改用户密码，存进去的密码是不加密的，或者修改头像导致用户的头像其实是相对路径而不是 url 等，都需要参考模型部分的 set{字段}Attribute 进行再加工。
    ```
    * 它的配置文件就是 config/administrator.php 和 创建的那两个文件夹，详情可以参考项目代码。
        * config/administrator.php => [总体配置](https://github.com/prohorry-me/larabbs/blob/master/config/administrator.php)
        * config/administrator/users.php => [关于 users 用户管理的配置](https://github.com/prohorry-me/larabbs/blob/master/config/administrator/users.php)
        * config/administrator/settings/site.php => [站点配置管理的相关配置](https://github.com/prohorry-me/larabbs/blob/master/config/administrator/settings/site.php)
    > 这个扩展包的工作逻辑就是：读相关配置，根据配置生成页面（包括列表、新建和编辑的表单、筛选等）、根据配置管理访问权限等。

# 计划任务
> 计划任务的工作逻辑就是：让已经部署好的站点隔一段时间自动执行某条命令，因此我们得先学会如何 **自定义 artisan 命令**
* 创建 artisan 命令 `php artisan make:command 命令文件名 --command='命令'` => 命令文件名就是 app/Console/Commands/ 目录下存放的自定义命令文件的名称， `--command='命令'` 的意思就是说执行这个自定义命令要输入的命令 `php artisan 命令`
* 一个常见的命令类文件的内容是这样的
```
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\User;

class CalculateActiveUser extends Command
{
    // 供我们调用命令
    protected $signature = 'larabbs:calculate-active-user';

    // 命令的描述
    protected $description = '生成活跃用户';

    // 最终执行的方法
    public function handle(User $user)
    {
        // 在命令行打印一行信息
        $this->info("开始计算...");

        $user->calculateAndCacheActiveUsers();

        $this->info("成功生成！");
    }
}
```
> `$signature` => 就是 `--command='命令'` 生成的命令
> `$description` => 是命令的说明描述，可以输入 `php artisan list` 查看所有命令。
> `handle()` 方法就是最重要的，指的是输入这条命令后，laravel 将做什么操作（这里是计算活跃用户，详情参考笔记 14.md）
> 在 handle 方法中有个 `$this->info('信息...')` => 这就是输出在控制台上的信息。
* 根据 `protected $signature = 'larabbs:calculate-active-user';` => 说明我们输入 `php artisan larabbs:calculate-active-user` 就可以执行这条命令了。现在我们需要让这条命令隔一段时间自动执行：即加入计划任务。
----------------------------------------------------------------------------------------
* 在开启计划任务之前，需要先让系统的 php 执行计划任务：运行以下命令：`export EDITOR=vi && crontab -e` 这是用 vim 打开 Cron 配置文件。
* 然后在打开的文件中末尾插入这段话 `* * * * * php /home/vagrant/Code/larabbs/artisan schedule:run >> /dev/null 2>&1` 然后保存（vim 编辑器操作相关知识，略）
* 此时就可以编辑 app/Console/Kernel.php@schedule 方法，在其中定制自己的计划任务了
```
protected function schedule(Schedule $schedule)
{
    $schedule->command('larabbs:calculate-active-user')->hourly(); // 每小时计算一次活跃用户
    $schedule->command('larabbs:sync-user-actived-at')->dailyAt('00:00'); //每天0点整执行一次同步登陆时间到数据库的命令
}
```
> `hourly()` => 命令每小时执行
> `dailyAt('时间')` => 命令根据操作系统的时间，在某个时间执行

# 自定义中间件
* 创建中间件 `php artisan make:middleware RecordLastActivedTime` => 中间件都位于 app/Http/Middleware/ 目录下，编辑新建的中间件 => 就是编辑类文件的 `handle()` 函数
```
# 举例：在用户登录之后记录用户登陆时间的中间件
<?php

namespace App\Http\Middleware;

use Closure;
use Auth;

class RecordLastActivedTime
{
    public function handle($request, Closure $next)
    {
        // 如果是登录用户的话
        if (Auth::check()) {
            // 记录最后登录时间
            Auth::user()->recordLastActivedAt();
        }

        return $next($request);
    }
}
```
* 注册中间件 app/Http/Kernel.php
```
// 定义中间件组
    protected $middlewareGroups = [

        // Web 中间件组，应用于 routes/web.php 路由文件
        'web' => [
            //...

            // 记录用户最后活跃时间
            \App\Http\Middleware\RecordLastActivedTime::class, // <= 添加
        ],
    ];
```
> 中间件的具体作用：过滤 http 请求。

# 小技巧
1. 自定义全局的助手函数
    * 新建存放助手函数的文件，建议命名为 bootstrap/helpers.php
    * 然后在 bootstrap/app.php 中
    ```
    <?php

    require_once __DIR__ . '/helpers.php'; //引用同目录下的 helpers.php 
    ```
    > 此时就可以在无论模型、控制器或者视图中使用 helpers.php 中定义的助手函数了。
2. 页面元素根据路由不同，自动变换类名 `class="动态变化"`
    * `<div id="app" class="{{ route_class() }}-page">` => 视图上的，这里的 `route_class()` 需要我们在全局助手函数 bootstrap/helpers.php 中定义
    * bootstrap/helpers@route_class => 返回值为根据当前路由名称返回不同的字符串。
    ```
    function route_class()
    {
        return str_replace('.', '-', Route::currentRouteName());
    }
    ```
    > `str_replace('要被替换的字符', '替换字符', 字符串)` => 将 **字符串** 中 **要被替换的字符** 替换成 **替换字符** 。
    > `Route::currentRouteName()` => 获取当前路由名称。就是 `Route::method()....->name('这里是路由名称')`
    > 这样做的好处就是：一个写死的 html 元素，但是它的 class 根据路由不同动态变化（路由不同页面不同）：我们可以配置不同页面下同一个元素的不同样式。
3. 要想快速实现用户认证，只需要：
    * 跑框架自带的两个迁移文件，创建 users 用户表和 password_resets 密码重置令牌表。 `php artisan migrate`
    * 一键生成控制器，4张视图（登陆，注册，忘记密码发邮件，密码重置），多条路由 `php artisan make:auth`
    * 有一个问题：上面生成的控制器的逻辑中，无论用户成功地做了哪些操作，都会将用户重定向到 `'/home'` 路由，如果你希望重定向到其他路由，比如 `'/'` ，那么就需要【ctrl】 + 【shift】 + 【f】 打开全局搜索，替换
    ```
    # LoginController.php
    # RegisterController.php
    # ResetPasswordController.php

    protected $redirectTo = '/'; // <= 上面3个控制器替换这里

    # RedirectIfAuthenticated.php
        public function handle($request, Closure $next, $guard = null)
        {
            if (Auth::guard($guard)->check()) {
                return redirect('/'); // <= 这个替换这里
            }

            return $next($request);
        }
    ```
    > 用 `#` 注释的，都是要替换内容的文件名。
    > vsCode 要使用全局搜索，需要添加项目文件夹到工作区。
4. 如果使用 `php artisan make:auth` 并且用 laravel 系统提供的模板的话，会自动在 head 部分写上 `<meta name="csrf-token" content="{{ csrf_token() }}">` ，当然如果我们自己写模板，建议也加上这一句：可以方便前端的 JS 代码读取框架中的 CSRF 令牌。
5. 更高效的数据填充
```
# 举例 TopicsTableSeeder.php
<?php

use Illuminate\Database\Seeder;
// 引用模型
use App\Models\Topic;
use App\Models\User;
use App\Models\Category;

class TopicsTableSeeder extends Seeder
{
    public function run()
    {
        // 获取所有的 user.id 和 category.id
        $userIds = User::all()->pluck('id')->toArray();
        $cateIds = Category::all()->pluck('id')->toArray();

        // 实例化 Faker
        $faker = app(Faker\Generator::class);

        // 创建数据
        $topics = factory(Topic::class)
            ->times(50)
            ->make()
            ->each(function($topic, $index) use ($userIds, $cateIds, $faker) { //用 each 遍历 make 出来的数据
                // 挨个给每条数据赋上随机的 user_id 和 category_id
                $topic->user_id = $faker->randomElement($userIds);
                $topic->category_id = $faker->randomElement($cateIds);
            });
        
        // 插入数据
        Topic::insert($topics->toArray());
    }
}
```
> 使用 `fcatory()->make()` 是最高效的。（比 create() 高效）
> 同时要学会 `$userIds = User::all()->pluck('id')->toArray();` 取出需要外键 id
> 然后用 `->each()` 遍历 make 出来的模拟数据，挨个赋值随机外键 `$topic->user_id = $faker->randomElement($userIds);`
> 在 Seeder 中实例化 Faker `$faker = app(Faker\Generator::class);`
6. 防止数据损坏
    * 给模型绑定监控器 ModelObserver，编辑 ModelObserver@deleting ，在删除的时候查一下外键是模型主键的数据，删了。
    * 利用 MySql 自带的外键约束：外键数据没了，对应表中的其他数据也干掉。
        * 这种需要先建外键关系 `php artisan make:migration add_references` 编辑
        ```
        ?php

        use Illuminate\Support\Facades\Schema;
        use Illuminate\Database\Schema\Blueprint;
        use Illuminate\Database\Migrations\Migration;

        class AddReferences extends Migration
        {
            public function up()
            {
                // 给 topics 表添加外键约束 => user_id
                Schema::table('topics', function (Blueprint $table) {

                    // 当 user_id 对应的 users 表数据被删除时，删除词条
                    $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
                });

                // 给 replies 表添加外键约束 => user_id, topic_id
                Schema::table('replies', function (Blueprint $table) {

                    // 当 user_id 对应的 users 表数据被删除时，删除此条数据
                    $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

                    // 当 topic_id 对应的 topics 表数据被删除时，删除此条数据
                    $table->foreign('topic_id')->references('id')->on('topics')->onDelete('cascade');
                });
            }

            public function down()
            {
                Schema::table('topics', function (Blueprint $table) {
                    // 移除外键约束
                    $table->dropForeign(['user_id']);
                });

                Schema::table('replies', function (Blueprint $table) {
                    $table->dropForeign(['user_id']);
                    $table->dropForeign(['topic_id']);
                });

            }
        }
        ```
        > 添加外键约束 `$table->foreign('外键字段名')->references('自己的主键通常就是id')->on('外键表名')->onDelete('cascade');`
        > 删除外键约束 `$table->dropForeign(['外键字段名']);`
7. 避免 N+1 次查询：就是绑定好模型关系之后，查询时用 `..->with('外键表')` 就OK。
8. SEO 优化
    * 友好的url => 教程中用请求百度翻译接口，翻译帖子标题，然后在地址后面加上 `.../翻译结果`
        * 配置路由 `Route::get('topics/{topic}/{slug?}', 'TopicsController@show')->name('topics.show');` => 将翻译结果 slug 弄成可选参数（因为示例数据没有 slug 并且有时候可能不一定每个帖子都能翻译出来）
        * 编写 app/Handlers/SlugTranslateHandler.php
        ```
        <?php
        
        namespace App\Handlers;

        use GuzzleHttp\Client;
        use Overtrue\Pinyin\Pinyin;

        class SlugTranslateHandler
        {
            public function translate($text) //参数就传帖子标题
            {
                // 实例化 GuzzleHttp/Client
                $http = new Client;

                // 初始化配置信息
                $appid = config('services.baidu_translate.appid'); //读取 config/services.php 文件中的信息
                $key = config('services.baidu_translate.key');

                // 如果没有配置百度翻译，自动使用兼容的拼音方案
                if (empty($appid) || empty($key)) {
                    return $this->pinyin($text);
                }

                // 根据文档，生成 sign
                // appid+q+salt+密钥 的MD5值
                $api = 'http://api.fanyi.baidu.com/api/trans/vip/translate?'; //请求接口地址
                $salt = time(); //按接口要求需要有一个 appid+查询关键字q+加盐代码+密钥 生成的 md5 认证，这里将加盐代码弄成当前时间戳
                $sign = md5($appid. $text . $salt . $key); //生成请求签名

                // 构建请求参数
                $query = http_build_query([
                    "q"     =>  $text, //查询关键字
                    "from"  => "zh", //过去的语言
                    "to"    => "en", //要求翻译成的语言
                    "appid" => $appid, //appip
                    "salt"  => $salt, //加盐代码
                    "sign"  => $sign, //签名
                ]); //最后生成 => 'q=$text&from=zh&to=en&appid=$appid&salg=$slat&sign=$sign'

                // 发送 HTTP Get 请求
                $response = $http->get($api.$query); // 请求地址就是 接口地址 . $query
                
                // 返回的是json，用 $response->getBody() 接收，然后用 json_decode 转成数组
                $result = json_decode($response->getBody(), true);

                /*
                    获取结果，如果请求成功，dd($result) 结果如下：

                    [▼
                        "from" => "zh"
                        "to" => "en"
                        "trans_result" => array:1 [▼
                            0 => array:2 [▼
                                "src" => "XSS 安全漏洞" //请求发送过去的文字
                                "dst" => "XSS security vulnerability" //翻译后的文字（我们需要的）
                            ]
                        ]
                    ]
                */

                // 尝试获取获取翻译结果
                if (isset($result['trans_result'][0]['dst'])) {
                    return str_slug($result['trans_result'][0]['dst']);
                } else {
                    // 如果百度翻译没有结果，使用拼音作为后备计划。
                    return $this->pinyin($text);
                }
            }

            public function pinyin($text)
            {
                return str_slug(app(Pinyin::class)->permalink($text));
            }
        }
        ```
        > 这里面用了 Guzzle 和 PinYin 两个扩展，详情参考第一部分 “各种扩展使用的 7、8 点”
        > 百度翻译的接口地址是 `http://api.fanyi.baidu.com/api/trans/vip/translate?q=【你要翻译的文字】&from=【要被翻译的文字的语言】&to=【要翻译成什么语言】&appid=【你注册的appid】&slat=【一个加盐代码建议用当前时间戳time()】&sign=【用md5加密(你的appid+要翻译的文字+加盐代码+你注册的key)】`
        * 创建队列任务 `php artisan make:job 任务名首字母大写驼峰命名法` => 创建在 app/Jobs/ 目录下，编辑我们的队列任务 app/Jobs/TranslateSlug.php
        ```
        <?php

        namespace App\Jobs;

        use Illuminate\Bus\Queueable;
        use Illuminate\Queue\SerializesModels;
        use Illuminate\Queue\InteractsWithQueue;
        use Illuminate\Contracts\Queue\ShouldQueue;
        use Illuminate\Foundation\Bus\Dispatchable;

        // 引用模型
        use App\Models\Topic;
        use App\Handlers\SlugTranslateHandler;

        class TranslateSlug implements ShouldQueue
        {
            use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

            protected $topic; //配置等下需要用的参数

            public function __construct(Topic $topic) //构造函数 通常用来给成员属性赋值 （配置参数）
            {
                $this->topic = $topic;
            }

            public function handle()
            {
                $slug = app(SlugTranslateHandler::class)->translate($this->topic->title); //调用 Handler 请求接口翻译 slug

                // 这里必须用 \DB::table() 来读取表数据然后修改，而不能实例化模型
                \DB::table('topics')->where('id', $this->topic->id)->update(['slug' => $slug]);
            }
        }
        ```
        > 队列任务需要相关扩展和配置，详情参考队列任务篇
        * 编辑 TopicObserver@saved
        ```
        use App\Jobs\TranslateSlug;

            ...

                public function saved(Topic $topic)
                {
                    // 如 slug 字段无内容，即使用翻译器对 title 进行翻译
                    if ( ! $topic->slug) {

                        // 推送任务到队列
                        dispatch(new TranslateSlug($topic));
                    }
                }
        ```
        * 编辑 Topic 模型，新增 link 方法：重定向到带 slug 的路由地址。
        ```
        public function link($params = [])
        {
            return route('topics.show', array_merge([$this->id, $this->slug], $params));
        }
        ```
        * 最后在 TopicsController@show 中确保访问的地址如果有 slug 始终带 slug
        ```
        ...
            // 添加这一段
            if(isset($topic->slug) && ($topic->slug != $request->slug)) {
                return redirect($topic->link(), 301); // 301 强制跳转
            }
        ...
        ```
    * 使用 laravel_adminitrator 的站点配置中生成出来的 seo 关键字，然后在视图上显示
        * 关于配置参考 权限管理-laravel_adminitrator 那一部分
        * 在视图上显示这些关键字通过
        ```
        <meta name="description" content="@yield('description', setting('seo_description', 'LaraBBS 爱好者社区。'))" />
        <meta name="keyword" content="@yield('keyword', setting('seo_keyword', 'LaraBBS,社区,论坛,开发者论坛'))" />
        ```
        > `setting('关键字', '默认值')` => 显示在后台管理站点配置中配置SEO关键字数据。